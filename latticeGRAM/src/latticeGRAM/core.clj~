(ns latticeGRAM.core)
(use '[clojure.string :only (split)])
(use '[clojure.java.io :only (reader)])
(use '[clojure.set])
(import '[clojure.lang PersistentQueue])

;(def inputFile (line-seq (reader "../../data/practiceFile.txt")))
;(def inputFile (line-seq (reader "../../data/larger.txt")))
(def inputFile (line-seq (reader "../../data/futbolData/output/nowindow.txt")))
(defn re-match? [re s] (not (nil? (re-find re s))))
(defn objectV? [s] (re-match? #"^[\w+\s*]+\-\-" s))
(def words (ref {}))
(def attr (ref {}))
;--------------------
;---READING FILES----
;--------------------
(defn findR [i]
  (doseq [h (split (last i) #";")]
    (let [v (first i)
          new (union (get @attr h) [v])]
      (cond (contains? @attr h)
            (dosync (alter attr merge {h new}))
            :else
            (dosync (alter attr assoc h [v]))))))

(defn readF [f]
  (let [cut (filter objectV? f)
        v1 (map #(split % #"--") cut)]
    (doseq [i v1]
      (def rev (future (findR i)))
      (dosync (alter words assoc (first i)
                     (split (last i) #";")))
      (deref rev))))

(time (readF inputFile))
;------------------
;--BREADTH FIRST---
;------------------
(def total2 (merge @words @attr))
(def subG (ref #{}))
(def wordList (keys @words)) 
(defn breadth-f [start]
  (def graphQueue
    (ref PersistentQueue/EMPTY))
  (def marked
    (ref #{start}))
  (dosync
   (alter graphQueue conj start))
  
  (while (seq @graphQueue)
    (let [top (peek @graphQueue)]
      (dosync
       (alter graphQueue pop))
      (doseq [i (get total2 top)]
        (if-not (contains? @marked i)
          (dosync
           (alter marked conj i)
           (alter graphQueue conj i))))))
  (dosync
   (alter subG conj @marked)))
;--------------------

(time (doseq [i wordList] 
       (breadth-f i)))

;; (time
;;  (let [f (map #(future (breadth-f %)) wordList)]
;;    (doseq [i f] (deref i))))


       
(println (count @subG))
(shutdown-agents)


;(doseq [i @subG]
;  (println i))
